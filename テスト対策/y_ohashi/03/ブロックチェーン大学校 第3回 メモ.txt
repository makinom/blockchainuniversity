■ブロックチェーン大学校 第3回
取引とブロックをビットレベルで検証

エンディアン
　普通一般はビッグエンディアン
　リトルエンディアンはバイトを逆にした形になる

符号
　最上位のビットが1になっているとマイナスの値を表現する

varint ( variable integer)

  254 = fd 00

  fd 00 80 = 23768 リトルエンディアンじゃなかったら fd 80 00

  0は複数の表現ができる

Big Interger

　8ビットがC++では最長の整数
　PSYのカンナムスタイルのPV数が-1になっちゃった事件（Youtube）

　256ビットの整数 = 32バイト

ScriptNum

　fullnodeのライブラリでScriptNumというクラス名になっている

固定小数点数
　ビットコインは（BTC）は常に固定で8桁の小数点で表示される
　サトシとビットコインは浮動小数点数ではない

浮動小数点数
　バイナリで表す場合、IEEE 754の規定に書いてある


公開鍵
　DER書式→取引の中で公開鍵を入れるときに使用
　非圧縮の公開鍵は使うべきではない→なるべくデータを小さくしたい

署名
　bitwise OR
  01 | 80 →81
  署名でまもっているのがなんなのか？をhashtypeで定義している

　h →　DERだよ
　l →　残りの署名の長さ
　rh →　これからrを出します
　rl　→ ｒの長さだよ
　rの値が最上位ビット1だった場合は00を頭につけるバイト数が1増える（rlが1増える）
　ほとんどの取引はSIGHASH_ALL

OPコード
　OP_numでマルチシグの数とか定義する

スクリプト
　OP_5　OP_5　OP_EQUALVERIFY
　OP_5 と OP_5が同じ値であるか？

取引の入力
　uint32LE LE=リトルエンディアン

　scriptSig 取引の中で使われるスクリプト
　scriptPubkey 公開鍵などパズルを提示しているデータの部分

取引
　varintの条件が253？なのでそれ以上の出力、入力は受け付けられない
　nlocktime 時間：取引が有効になる時間。それまでは署名とかそろってても有効にならない。
　　　　　　ブロック高：ブロックの高さ？を見る

ブロックチェーンから
　795b88d47a74e3be0948fc9d1b4737f96097474d57151afa6f77c787961e47cc
　を逆にすると取引が見つかるよ。

　88　EUQAL_VERIFY
　ac　CHECK_SIG

ブロックの構成
　マークルルート　取引リストの要約

マークル木（ハッシュツリー）
　奇数のデータの場合は最後の1つを複製してハッシュをとる
　
　可能ならSPVモードじゃなくてフルノードでブロックチェーンを検証したほうがよい

目標値（難易度）
　「難易度」は「目標値」に反比例する。「難易度」が下がれば「目標値」は上がる
　4バイトの浮動小数点でブロックヘッダにて記載する
　1ビット目標値が下がると2倍の難しさになる

ブロックヘッダ
　version: 4バイトがフラグとして存在している。ソフトフォークを投票するための場所。投票の使いまわしができるようになっている。ほとんどのブロックエクスプローラーは対応していない。もともと数値だったが今はビット。
　prevblockhash: 32バイト
　merklroot: 32バイト
	　time: 不正確なタイムスタンプになっている。2時間くらいのバッファがある。次のブロックのほうが早い。みたいなのがある。ノンスを回し切ったとかいう理由でマイナーでタイムスタンプを変えて採掘するケースもある。

ブロック
　magicnum: いつも同じ
　ブロックの最大値いまは1MB

①
00000000_00000000_00000000_00000000_XXXXXX
00000000_00000000_00000000_00000000_YYYYYY

②ハッシュ値をいれる

③sha256でハッシュ

④[h1'']と[h2''] 昔のブロックであればあるほど簡単（コインベース取引しかないのは出せない。取引が1つしかないから）

































バイト　ビット

ブルームフィルター